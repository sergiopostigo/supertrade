from pygam import LinearGAM, s, f, l, terms
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

class model:

    def __init__(self,
                 explanatory_variables,
                 target_variable,
                 target_name,
                 timepoints,
                 training_fraction,
                 steps=None):
        # multi-step approach
        if steps != None:
            self.X = explanatory_variables[:-steps]
            self.y = target_variable[steps:]
            self.timepoints = timepoints[steps:]
        # non multi-step approach
        else:
            self.X = explanatory_variables
            self.y = target_variable
            self.timepoints = timepoints
        # training and test sets
        self.train_size = int(training_fraction * len(self.X))
        self.X_train, self.X_test = self.X[:self.train_size], self.X[self.train_size:]
        self.y_train, self.y_test = self.y[:self.train_size], self.y[self.train_size:]

        # name of target variable
        self.target_name = target_name
    def train(self):
        # Iterate trough each predictor and define the function to apply for it in the GAM
        my_terms = terms.TermList()
        for i in range(self.X_train.shape[1]):
            if i==0: # Trend (is the first column in X_train)
                my_terms += l(i)
            else: # The rest of the columns are the seasonalities
                my_terms += s(i, basis='cp')

        # Fit the model
        self.model = LinearGAM(my_terms).gridsearch(self.X_train,self.y_train)

    def predict(self, X_pred):
        # Make predictions
        self.y_pred = self.model.predict(X_pred)
        # Confidence interval
        self.conf_in = self.model.prediction_intervals(X_pred, width=0.95)

    def test(self):
        # Train the model
        self.train()
        # Predict with test data
        self.predict(self.X_test)
        # Get testing metrics
        rmse = np.sqrt(mean_squared_error(self.y_test, self.y_pred))
        mae = mean_absolute_error(self.y_test, self.y_pred)
        metrics_dict = {"rmse":rmse,
                        "mae":mae}

        return metrics_dict

    def plot_test(self):

        # Plot original vs predicted
        plt.figure(figsize=(18, 6))
        sns.lineplot(x=self.timepoints[self.train_size:], y=self.y_test, label='Original')
        sns.lineplot(x=self.timepoints[self.train_size:], y=self.y_pred, label='Predicted')
        plt.fill_between(self.timepoints[self.train_size:],
                         self.conf_in[:,0],
                         self.conf_in[:,1],
                         color='gray',
                         alpha=0.3,
                         label='Confidence Interval')
        plt.xlabel('Time')
        plt.ylabel(self.target_name)
        plt.title('Original vs Predicted')
        plt.legend()