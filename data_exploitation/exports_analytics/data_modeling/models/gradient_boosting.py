from sklearn import ensemble
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

class model:

    def __init__(self,
                 explanatory_variables,
                 target_variable,
                 target_name,
                 timepoints,
                 training_fraction,
                 steps=None):
        # multi-step approach
        if steps != None:
            self.X = explanatory_variables[:-steps]
            self.y = target_variable[steps:]
            self.timepoints = timepoints[steps:]
        # non multi-step approach
        else:
            self.X = explanatory_variables
            self.y = target_variable
            self.timepoints = timepoints
        # training and test sets
        self.train_size = int(training_fraction * len(self.X))
        self.X_train, self.X_test = self.X[:self.train_size], self.X[self.train_size:]
        self.y_train, self.y_test = self.y[:self.train_size], self.y[self.train_size:]

        # name of target variable
        self.target_name = target_name
    def train(self):
        # Configurations
        params = {
            "n_estimators": 2000,
            "max_depth": 4,
            "min_samples_split": 10,
            "learning_rate": 0.01,
            "loss": "squared_error",
        }
        # Fit the model
        self.model = ensemble.GradientBoostingRegressor(**params).fit(self.X_train, self.y_train)

    def predict(self, X_pred):
        # Make predictions
        self.y_pred = self.model.predict(X_pred)

    def test(self):
        # Train the model
        self.train()
        # Predict with test data
        self.predict(self.X_test)
        # Get testing metrics
        rmse = np.sqrt(mean_squared_error(self.y_test, self.y_pred))
        mae = mean_absolute_error(self.y_test, self.y_pred)
        metrics_dict = {"rmse":rmse,
                        "mae":mae}

        return metrics_dict

    def plot_test(self):

        # Plot original vs predicted
        plt.figure(figsize=(18, 6))
        sns.lineplot(x=self.timepoints[self.train_size:], y=self.y_test, label='Original')
        sns.lineplot(x=self.timepoints[self.train_size:], y=self.y_pred, label='Predicted')
        plt.xlabel('Time')
        plt.ylabel(self.target_name)
        plt.title('Original vs Predicted')
        plt.legend()



