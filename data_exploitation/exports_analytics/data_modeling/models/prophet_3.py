from prophet import Prophet
import pandas as pd
from sklearn.metrics import mean_squared_error, mean_absolute_error
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

class model:

    def __init__(self,
                 explanatory_variables,
                 target_variable,
                 target_name,
                 timepoints,
                 training_fraction,
                 steps=None):
        # multi-step approach
        if steps != None:
            self.X = explanatory_variables[:-steps]
            self.y = target_variable[steps:]
            self.timepoints = timepoints[steps:]
        # non multi-step approach
        else:
            self.X = explanatory_variables
            self.y = target_variable
            self.timepoints = timepoints
        # training and test sets
        self.train_size = int(training_fraction * len(self.X))
        self.prophet_train, self.prophet_test = self.dataset()

        # name of target variable
        self.target_name = target_name

    def dataset(self):
        df = pd.DataFrame({'ds': self.timepoints, 'y' : self.y})
        # Add the trend and seasonalities
        for i in range(self.X.shape[1]):
            df[str(i)] = self.X[:,i] # the names of the columns are integers, 0 is the trend and the rest are seasonalities

        prophet_train = df.iloc[:self.train_size]
        prophet_test = df.iloc[self.train_size:]

        return prophet_train, prophet_test

    def train(self):

        # # Create the model and remove the default seasonalities
        self.model = Prophet(weekly_seasonality=False, yearly_seasonality=False)
        # Indicate the model to use the trend pattern and the seasonalities
        for i in range (self.X.shape[1]):
            self.model.add_regressor(str(i), standardize=False)
        # Fit the model
        self.model.fit(self.prophet_train)

    def predict(self, prophet_pred):
        # Make predictions
        self.y_pred = self.model.predict(prophet_pred)

    def test(self):
        # Train the model
        self.train()
        # Predict with test data
        self.predict(self.prophet_test)
        # Get testing metrics
        rmse = np.sqrt(mean_squared_error(self.prophet_test['y'], self.y_pred['yhat']))
        mae = mean_absolute_error(self.prophet_test['y'], self.y_pred['yhat'])
        metrics_dict = {"rmse":rmse,
                        "mae":mae}

        return metrics_dict

    def plot_test(self):

        # Plot original vs predicted
        plt.figure(figsize=(18, 6))
        sns.lineplot(x=self.timepoints[self.train_size:], y=self.prophet_test['y'], label='Original')
        sns.lineplot(x=self.timepoints[self.train_size:], y=self.y_pred['yhat'], label='Predicted')
        plt.fill_between(self.timepoints[self.train_size:],
                         self.y_pred['yhat_lower'],
                         self.y_pred['yhat_upper'],
                         color='gray',
                         alpha=0.3,
                         label='95% Confidence Interval')
        plt.xlabel('Time')
        plt.ylabel(self.target_name)
        plt.title('Original vs Predicted')
        plt.legend()